/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/

/*******************************************************************************
 * Filename:
 * ---------
 * rmmi_context.h
 *
 * Project:
 * --------
 *   MT6208
 *
 * Description:
 * ------------
 *   This file is intends for ï¿½K.
 *
 * Author:
 * -------
 * -------
 *
 *==============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *==============================================================================
 *******************************************************************************/

/********************************************************************************
*  Copyright Statement:
*  --------------------
*
*  This product has been developed using a protocol stack
*  developed by Sasken Communication Technologies Limited.
*
********************************************************************************/

#ifndef _RMMI_CONTEXT_H
#define _RMMI_CONTEXT_H

//#include "Kal_release.h"        /* in dir. Kal */

//#include "stacklib.h"
//#include "event_shed.h"
//#include "fat_fs.h"     //BT_DEBUG

//#include "rmmi_gati.h" 
#include "l4c_common_enum.h"


#include "ps2sat_struct.h"
//#include "l4c2phb_enums.h"
#include "mcd_l4_common.h"

//#include "l3_inc_enums.h"
#include "as2l4c_struct.h"
#include "rmmi_common_enum.h"
//#include "kal_non_specific_general_types.h"
#include "fs_type.h"

#include "kal_general_types.h"
#include "cmux_vp_num.h"
#include "ps_public_enum.h"
#include "kal_public_api.h"

#include "l4c2phb_struct.h"
#include "l4c_aux_struct.h"

#include "med_struct.h"

#include "sim_public_enum.h"
#include "rmmi_struct.h"
#include "smu_common_enums.h"
//#include "csmcc_types.h"
//#include "tcm_context.h"

#define _MULTI_TCM_USER_

#define NULL_TERM '\0'  /* string termination */
#define INVALID_ENUM 255        /* invalid enum value */

#define RMMI_PTR        rmmi_ptr_g
#define RMMI_COMM_PTR   rmmi_common_ptr_g

#define rmmi_skip_spaces(source_string_ptr)                                  \
      while( source_string_ptr->string_ptr[ source_string_ptr->index ]       \
                                 == RMMI_SPACE )                             \
      {                                                                      \
        source_string_ptr->index++;                                          \
      }
//030617 mtk00468 add for skip unused character before character a 
#define rmmi_skip_none_a(source_string_ptr, length)                                                                                \
      while( (source_string_ptr->index < length) && !((source_string_ptr->string_ptr[ source_string_ptr->index ] == RMMI_CHAR_A) ||\
             (source_string_ptr->string_ptr[ source_string_ptr->index ] == rmmi_char_a)) )                                         \
      {                                                                                                                            \
        source_string_ptr->index++;                                                                                                \
      }

#define RMMI_IS_LOWER( alpha_char )   \
  ( ( (alpha_char >= rmmi_char_a) && (alpha_char <= rmmi_char_z) ) ?  1 : 0 )

#define RMMI_IS_UPPER( alpha_char )   \
   ( ( (alpha_char >= RMMI_CHAR_A) && (alpha_char <= RMMI_CHAR_Z) ) ? 1 : 0 )

#define RMMI_IS_HEX_ALPHA( alpha_char )   \
   ( ( (alpha_char >= RMMI_CHAR_A) && (alpha_char <= RMMI_CHAR_F) ) ? 1 : 0 )

#define RMMI_IS_NUMBER( alpha_char )   \
   ( ( (alpha_char >= RMMI_CHAR_0) && (alpha_char <= RMMI_CHAR_9) ) ? 1 : 0 )

#define RMMI_IS_ALPHA( alpha_char )   \
   ( ( RMMI_IS_UPPER(alpha_char) || RMMI_IS_LOWER(alpha_char) ) ? 1 : 0 )

#define RMMI_IS_SYMBOL( alpha_char )                                          \
   ( ( (alpha_char == RMMI_CHAR_PLUS) || (alpha_char == RMMI_CHAR_STAR) ||    \
       (alpha_char == RMMI_CHAR_POUND) || (alpha_char == RMMI_COMMA) ||       \
       (alpha_char == RMMI_CHAR_DOT) || (alpha_char == RMMI_FORWARD_SLASH) || \
       (alpha_char == RMMI_COLON) || (alpha_char == RMMI_HAT) ||              \
       (alpha_char == RMMI_CHAR_MINUS) ||                                     \
       (alpha_char == RMMI_L_SQ_BRACKET) ||                                   \
       (alpha_char == RMMI_R_SQ_BRACKET) ||                                   \
       (alpha_char == RMMI_L_ANGLE_BRACKET) ||                                \
        (alpha_char == RMMI_CHAR_ULINE) ||                                    \
         (alpha_char == RMMI_SPACE) ||                                        \
           (alpha_char == RMMI_SEMICOLON) ||                                  \
       (alpha_char == RMMI_R_ANGLE_BRACKET)                                   \
     ) ? 1 : 0 )

#define RMMI_IS_EXT_CHAR( alpha_char )                                                  \
   (((alpha_char == RMMI_HAT)||(alpha_char == RMMI_CHAR_TILDE)||(alpha_char == RMMI_EURO)||\
   (alpha_char == RMMI_L_SQ_BRACKET) || (alpha_char == RMMI_R_SQ_BRACKET) ||            \
   (alpha_char == RMMI_L_CURLY_BRACKET) || (alpha_char == RMMI_R_CURLY_BRACKET) ||      \
   (alpha_char == RMMI_CHAR_REVERSE_SOLIDUS) ||(alpha_char == RMMI_CHAR_VERTICAL_LINE)  \
   ) ? 1 : 0 )

//#if !defined(__MTK_TARGET__) && defined(__RMMI_UT__)
//#define RMMI_UART_GetOwnerID(port) rmmi_current_mod_id
//#endif


typedef kal_bool(*UART_TRANS_FUNC_PTR) (kal_uint8);

typedef kal_uint64  RMMI_UART_FLAG;


typedef struct rmmi_single_cmd_struct
{
    kal_uint16 cmd_code;    /* rmmi_extended_cmd_id_enum */
    kal_uint8 cmd_mode;     /* rmmi_cmd_mode_enum */
} rmmi_single_cmd_struct;

typedef struct basic_cmd_struct
{
    kal_uint8 cmd_code; /* rmmi_basic_cmd_id_enum */
    kal_uint8 cmd_mode; /* rmmi_cmd_mode_enum */

    kal_bool is_this_node_used;
    kal_uint8 value;

    struct basic_cmd_struct *next_ptr;
} rmmi_multiple_basic_cmd_struct;

typedef struct rmmi_cmd_struct
{
    kal_uint8 which_present;    /* rmmi_cmd_type_enum */

    rmmi_single_cmd_struct single_cmd;
    rmmi_multiple_basic_cmd_struct multiple_cmd;        //not used now
} rmmi_cmd_struct;

typedef struct
{
    kal_uint8 s0;   /* auto answer */
    kal_uint8 s2;   /* escape character (+++) */
    kal_uint8 s3;   /* CR */
    kal_uint8 s4;   /* LF */
    kal_uint8 s5;   /* backspace */
    kal_uint8 s6;   /* pause before dialing */
    kal_uint8 s7;   /* connect timeout */
    kal_uint8 s8;   /* , pause time */
    kal_uint8 s10;  /* disconnect timeout */
    kal_uint8 s32;  /* XON character */
    kal_uint8 s33;  /* XOFF character */
    kal_uint8 s95;

} rmmi_s_register_struct;

typedef struct uart_queue_struct
{
    kal_uint16 head;
    kal_uint16 length;
    kal_uint8 data[MAX_DATA_QUEUE_LENGTH];

} rmmi_uart_queue_struct;

typedef struct
{
    kal_uint16 head;
    kal_uint16 length;
    kal_uint8 data[MAX_DATA_QUEUE_LENGTH];

} rmmi_uart_output_queue_struct;

typedef struct
{

    kal_bool sat_in_menu;
    kal_bool sat_in_process;
    kal_bool sat_normal_standby;
    kal_bool sat_ready;
    kal_uint8 sat_input_type;
    kal_uint8 sat_input_reveal;
    kal_uint8 sat_input_min_len;
    kal_uint8 sat_input_max_len;
    kal_bool sat_redial;
    kal_bool sat_redial_count;
    kal_uint32 sat_duration;

} rmmi_SAT_info_struct;

typedef struct rmmi_cind_struct
{
    kal_uint8 battchg;
    kal_uint8 signal;
    kal_uint8 service;
    kal_uint8 message;
    kal_uint8 call;
    kal_uint8 roam;
    kal_uint8 smsfull;
    kal_uint8 callsetup;
    kal_uint8 callheld; //for BT HF 1.5
} rmmi_cind_struct;

typedef struct rmmi_reg_state_struct
{
    kal_uint32 cell_id;     // for +CREG and +CGREG and +CEREG, high 16 bits for RNC id, low 16 bits for cell_id
    kal_uint16 lac_or_tac_value;   // for +CREG and +CGREG and +CEREG
    kal_uint8 rac_value;    // for +CGREG
    kal_uint8 act;          //[MAUI_01360129]
    kal_uint8 state;    //for +CREG and +CGREG and +CEREG
    kal_uint8 cause;
    data_speed_support_enum cell_data_speed_support;
    kal_uint8 plmn_id[MAX_PLMN_LEN+1];
    kal_bool is_csg_cell;
    csg_info_struct csg_info;
    kal_uint8 csg_state;    //for +ECSG
} rmmi_reg_state_struct;

typedef struct rmmi_ims_reg_state_struct
{
    kal_uint8 reg_info;
    kal_uint32 ext_info;
} rmmi_ims_reg_state_struct;


/* init by l4cphb_start_cnf_hdlr */
typedef struct rmmi_phb_info_struct
{
    kal_uint8 sim_phb_len;      //max length of name in SIM EFadn
    kal_uint8 sim_fdn_len;      //max length of name in EFfdn    
    kal_uint8 msisdn_alpha_length; //max length of EFmsisdn    
    kal_uint8 sim_email_len;       // max length of email in EF_EMAIL
} rmmi_phb_info_struct;

typedef struct 
{
    l4c_phb_entry_struct entry;
    l4c_number_struct num[3];
    phb_sne_struct sne;
    phb_email_struct email;
} rmmi_phb_cpbw_struct;

typedef struct rmmi_clip_info_struct
{
    kal_uint8 number[MAX_CC_ADDR_LEN];       //MAX_CC_ADDR_LEN
    kal_uint8 type;
    kal_uint8 subaddr[MAX_CC_SUB_ADDR_LEN];      //MAX_CC_SUB_ADDR_LEN
    kal_uint8 satype;
    kal_uint8 cli_validity;
} rmmi_clip_info_struct;

typedef struct rmmi_cbst_struct
{
    kal_uint8 speed;
    kal_uint8 name;
    kal_uint8 ce;
} rmmi_cbst_struct;

typedef struct rmmi_crlp_strnct
{
    kal_uint8 iws;
    kal_uint8 mws;
    kal_uint8 T1;
    kal_uint8 N2;
} rmmi_crlp_strnct;

typedef struct rmmi_profile_struct
{
    rmmi_s_register_struct s_reg;
    rmmi_cbst_struct rmmi_cbst;
    rmmi_crlp_strnct rmmi_crlp;
    kal_uint8 rmmi_ciwf;
    kal_uint8 rmmi_atv;
    kal_uint8 rmmi_ate;
    kal_uint8 rmmi_atq;
    kal_uint8 rmmi_atx;
    kal_uint8 rmmi_atw;
    kal_uint8 rmmi_atampC;
    kal_uint8 rmmi_atampD;
    kal_uint8 rmmi_atampK;
} rmmi_profile_struct;

typedef struct
{
   kal_uint8	reason;
   kal_uint8	mode;
   kal_uint8	timer;
   l4c_number_struct    dest_buffer;
   l4c_sub_addr_struct    sub_dest_buffer;
   kal_bool     sub_addr_flag;
} ccfc_req_param_struct; /* for remembering params of AT+CFCC */

typedef struct
{
   kal_uint8	mode;
} ccwa_req_param_struct; /* for remembering params of AT+CCWA */

typedef struct
{
   kal_uint8	reason;
   kal_uint8	mode;
   kal_uint8 passwd[4];
} clck_ss_req_param_struct; /* for remembering params of AT+CLCK */

typedef struct rmmi_transfer_struct
{
    module_type dest_mod; 
    UART_PORT port; 
} rmmi_transfer_struct;


typedef struct rmmi_common_context_struct
{
#ifdef __CMUX_SUPPORT__
    kal_uint8   physical_port;
    kal_bool    cmux_enable;
#endif /* __CMUX_SUPPORT__ */

#ifdef __BT_SUPPORT__
    kal_uint8 rmmi_hf_src;
    kal_bool hf_urc_report_flag;
#endif

#if defined(__PHB_STORAGE_BY_MMI__)
    /***********************************************
    * It is more appropriate to use a structure to contain the info. 
    * for different PHB type. But, we only need to remember the info of ME PHB currently,
    * So we can do this in the future if needed.
    ************************************************/
    kal_uint16 phb_me_total;
    kal_uint16 phb_me_used;
    kal_uint16 phb_me_free;
    kal_uint16 phb_me_max_name_len;
    kal_uint16 phb_me_max_num_len;
    kal_uint16 phb_me_max_email_len;
#endif 


    RMMI_UART_FLAG isAtdAction_flag; /* mtk00714 20040412 : remember ATD this action after setup_cnf */
    RMMI_UART_FLAG isAtdAbort_flag;  /* mtk01616 070323 to know it's a Atd abort by any character  */

#if defined(__CMUX_MODEM_STATUS_SUPPORT__)	 
    RMMI_UART_FLAG isDSRAbort_flag;
#endif  

#ifdef SYNCML_DM_SUPPORT
    kal_bool lock_atci; 
#endif
#if defined(__GEMINI__)||defined(__SGLTE__)
    rmmi_sim_uart_setting_enum sim_uart_setting;
    sim_interface_enum rmmi_uart_owner[RMMI_MAX_CHANNEL_NUMBER];
#endif
    RMMI_UART_FLAG uart_plugout;
    RMMI_UART_FLAG uart_stop_send_flag;
    RMMI_UART_FLAG is_multi_cmd;
    RMMI_UART_FLAG multi_cmd_error;  // this flag using to verify if error occur , we should abort command processor
    RMMI_UART_FLAG is_sms_cmd;       //using to cehck string is sms command and send " > " to DTE

    kal_uint8 source[RMMI_MAX_CHANNEL_NUMBER]; 
    kal_uint8 port[RMMI_MAX_CHANNEL_NUMBER]; 
    kal_uint8 uart_port_value; /* this value store the default value form NVRAM */    
    rmmi_transfer_struct transfer; 


    rmmi_uart_queue_struct uart_input_queue[RMMI_MAX_CHANNEL_NUMBER];
    rmmi_uart_queue_struct uart_output_queue[RMMI_MAX_CHANNEL_NUMBER];
    kal_uint8 multi_cmd_string[RMMI_MAX_CHANNEL_NUMBER][MAX_MULTIPLE_CMD_INFO_LEN];

#ifdef __TC01__    
    kal_uint8 gkpd_flag;       
    kal_uint8 gkpd_buffer[20]; 
    kal_uint16 gkpd_count; 
    kal_uint8 *gkpd_windex; 
    kal_uint8 *gkpd_rindex; 
    kal_uint32 gkpd_current_rindex;
    kal_uint16 gkpd_rindex_count;
    kal_uint8 mpt_flag;  
#endif 

#if defined(__AT_ETSTLP_SUPPORT__) || !defined(__MMI_FMI__)
    kal_uint8 etstlp_port[2]; //for tst_port_ps and tst_port_l1
#endif

    kal_uint8 gsm_tx_pwr_reduction_tbl[4][2][4];
    kal_uint8 umts_tx_pwr_reduction_tbl[20][2];

    kal_uint8 is_rrm_test; // work around for RRM test, EMM need special power off without sending detach

#ifndef __MTK_TARGET__
    kal_uint8 ut_uart_input[MAX_UT_UART_LENGTH];
    kal_uint16 ut_uart_input_len;
#endif
} rmmi_common_context_struct;

typedef struct rmmi_context_struct
{
/*************************************************************************/
/* Below context are placed in the front of RMMI context                 */
/* to increase immediate offset access , to reduce ROM size              */
/* Please KEEP the position for the following frequent used variables    */
/*************************************************************************/
    kal_uint8 current_src;
    kal_bool is_sent_to_current_src ; // If KAL_FALSE, send MSG to URC channel 
    kal_uint8 char_set; //+CSCS
    rmmi_phb_type_enum phb_storage_type;  
    kal_bool is_ucm_action;        
    kal_uint16 cmee_err;        // error value for +CME:<err>
    kal_bool uart_in_data_mode;
    kal_uint8 online_cmd_state;


    kal_uint8 response_type;

    kal_bool ats0_auto_answer;  //mtk01616_070707 add this to prevent print OK for auto answer 
#ifdef __UCM_SUPPORT__
    kal_bool is_ata_action;     //mtk01616_070707 add this to handle ATA result code
    kal_bool is_compound_action; //MAUI_02016224
#endif

    /* use to check if sim verified */
    kal_bool command_allow;     // using to keep if password required, only some AT command can access when pin puk or ph_sim pending
    kal_uint16 cmd_error_cause; // SMU saves command not allow cause for +cme error value to TA 
    
    rmmi_s_register_struct s_reg;
    void *arg_list[RMMI_MAX_ARG_NUM];

    rmmi_rsp_mode_struct rsp_mode;
    rmmi_cind_struct indicators;        // for +CIND and +CMER 
    rmmi_report_mode_struct report_mode;
    rmmi_reg_state_struct cs_register_status; //registration status for +CREG
#ifdef __MOD_TCM__
    rmmi_reg_state_struct ps_register_status; //registration status for +CGREG
    l4c_data_bearer_capablility_enum psbearer_param2; //the last reported <bearer_capability> in +PSBEARER
#endif

#ifdef __L4C_GPRS_UT__
    ps_cause_enum cause;
#endif

    rmmi_ecc_number_list_struct ecc_number; /* to store ECC number from network, related to +CEN */
    
/***********************************************************************/
/* Above context are placed in the front of L4C context                */
/* to increase immediate offset access , to reduce ROM size            */
/* Please try to KEEP the position for these frequent used variables   */
/***********************************************************************/

#ifdef __IMS_SUPPORT__
    rmmi_ims_reg_state_struct ims_register_status;
    kal_uint8 imsvops_indication; // IMS Voice over PS session indication
    kal_uint8 emb_Iu_supp; // Emergency bearer services support indicator for Iu mode
    kal_uint8 emb_S1_supp; // Emergency bearer services support indicator for S1 mode
#endif

    /* settings */
    kal_uint8 em_enable;        //mtk00468 add for using to keep the em enable or disable engineer mode information
    kal_uint8 date_aux_mode;    // this variable using for +CSDF to keep in local
    kal_uint8 cring_type;       //mtk00714 add for +CRC (remember cring_type for rmmi_ring_repeat_hdlr)
    kal_uint8 error_report_mode;        //  /* +CMEE <mode>: rmmi_error_report_mode_enum */
    kal_uint8 plmn_format;
#ifdef __PLMN_LIST_WITH_LAC__
    kal_bool list_plmn_with_lac; //print LAC for +COPS=? response
#endif
    kal_uint8 cops_mode;
    kal_uint8 CPOL_plmn_format;
    kal_uint8 smsal_bfr;                    /* +CNMI : <bfr> */
    kal_uint8 CNMI_mode;        // +CNMI: <mode>: result code mode 
    //kal_uint16 max_plmn_list_len;       //+CPOL ?
    kal_bool cb_mode;
    kal_bool csdh_show; //mtk00714: for +CSDH , hide/show detail Text mode parameters.
    kal_bool clae_mode; // we save clae mode in rmmi context
    kal_bool cmut_mode; // we save clae mode in rmmi context
    kal_uint8 preferred_lang;
    kal_uint8 ring_count;       // for ATS0
    rmmi_phb_info_struct phb_info;
    rmmi_clip_info_struct clip_info;
    kal_uint8 casp_soundID;     //for +CASP proprietary command , timeout hdlr parameter.
    //kal_bool is_gprs_data_dialing;  /* ATH is not allowed to hangup existed voice call after dialup failed */ //mtk02285, 201003, 6251_ram
#ifdef __MOD_TCM__
    kal_uint8 cgatt_last_action;    /* mtk00714 20040611 add to avoid continuos at+cgatt=0 or at+cgatt=1 */
#endif //mtk02285, 201003, 6251_ram
    kal_uint16 cpbr_range[2];
    kal_uint16 phb_del_index;
    kal_uint8 phb_del_storage;
    kal_uint8 cpbr_ln_base_index;
    
    kal_uint8 ecpbr_num_index;   
    kal_uint8 ecpbr_entry_found;
    l4_name_struct ecpbr_alphaId;
    
    kal_uint8 ecpbw_num_index; 
    kal_uint8 ecpbw_email_write;
    kal_uint16 ecpbw_record_index;
    kal_uint8 ecpbw_is_delete;
    rmmi_phb_cpbw_struct *ecpbw_entry_ptr;

    #ifdef __OP01__
    rmmi_op01_report_mode_struct op01_report_mode;
    #endif

    kal_bool is_cpbw_phb_fdn; 

    #if 0
    #ifdef __AT_EPBW_SUPPORT__
/* under construction !*/
#endif
    #endif

	l4c_source_id_enum online_cmd_state_src_id; //MAUI_01652672, mtk02285, 20090324

#ifdef __IRDA_SUPPORT__
    //kal_uint8 ppp_nsapi; //mtk02285, 201003, 6251_ram
#endif 

#ifdef __RSAT__
    kal_bool sat_icon_displayed;        //mtk00924: display icon for STK SMS, SS, USSD, DTMF
#endif /* __RSAT__ */ 


    kal_uint8 except_src;       //for unsolicited code, but don't send it to this src. ex. MT data call, don't send RING to bt hs
    kal_uint8 imei_action;      //rmmi_imei_action_enum
    kal_uint8 rmmi_atd_mem;      //mtk01616_090116 :rmmi_mem_dial_enum
    #if defined(__MMI_FMI__)    
    kal_bool MMI_string_enable;
    kal_bool screenshot_pending;
    FS_HANDLE screenshot_fd;
    kal_uint16 screenshot_index;
    #endif
    kal_uint16 action_cmd;      //rmmi_extended_cmd_id_enum
    kal_uint8 ws46;
#ifdef __BT_SUPPORT__
    kal_uint8 last_reported_ciev_signal; //hong_rx_level
    kal_bool send_ciev_callheld; //mtk01616_090923: explictly to send +CIEV:<callheld> even the status is not changed
#endif
    kal_uint8 ath_for_dialup;   //mtk01616_080923: ATH is for dialup failure, we use this to  prevent ATH to disconnect call
    kal_uint8 last_number_dialed[MAX_CC_ADDR_LEN];//atdL last number dialed 

#if 0 //__CTM_SUPPORT__
/* under construction !*/
#endif 

    kal_uint8 em_volume_level;
    kal_uint8 em_volume_type;
    kal_uint8 em_audio_type;
    kal_uint8 em_audio_gain;
    kal_uint8 em_audio_mode;
    kal_uint8 em_eadp_action;

    /* Context for AT+EAPS */
    kal_uint8 eaps_action;
    kal_uint8 eaps_para1;
    kal_uint8 eaps_para2;
    kal_uint8 eaps_para3;
    void* eaps_audio_param;

#ifdef __VOIP__
    kal_bool cm_cmd_approve;    //Send Call Management command to MMI to get approval 
    void *string_ptr;
    void *node_ptr;
    void *id;
#endif /* __VOIP__ */ 
#if !defined(__MMI_FMI__)
    kal_uint8 poweroff_src_id;
    kal_uint8 is_spn_valid;
    kal_uint8 spn[17];
#endif 

    kal_uint32 eind_ready_flag;
    kal_uint8 vgr_gain;
    kal_uint8 vgt_gain;

    kal_uint16 last_executed_P2_fail; //[MAUI_01292349] mtk02480l 27.007: +CPIN? return  PIN2/PUK2 if previous command execured authentication failure, i.e. cmee_err= 17/18    	

#if defined(__MODEM_EM_MODE__)
    kal_uint8 em_src_id;  // used to remember EM request src_id
#endif 

    #ifdef __GATI_ENABLE__
    gati_mod_src_struct gati_mod_src_table[GATI_MAX_MODULE_COUNT];	/* The table which record the relation of module to src_id and its control status */
    kal_uint8 gati_binary_mode_module[MAX_SOURCE_NUM];	/* The module id that active the binary mode for specific source id */
    kal_uint32 gati_stop_read_data_from_uart;						/* The bit map to specify which src_id is now stop receiving data from the UART */
    kal_uint32 gati_pending_rtr_ind;								/* The bit map to specify if there are rtr indication from the UART during the ATCI stop receiving data from the UART */
    gati_buffer_struct	gati_buffer;										/* The buffer will be used when the mode is in the binary mode and there is some data from other module which does not active the binary mode. */
    kal_uint8 gati_buffer_count;
    /* The following variables are temp ones used to transmit informations between functions */
    kal_bool	gati_write_allow_flag;					/* This flag is used to allow the writing action for the owner of the binary mode */
    kal_uint16 gati_actual_write;						/* This variable is used to get the actual write size to the output queue in the rmmi_uart_write_data */
    kal_uint8 gati_data_type;							/* This variable is used to know if the data type is integrity or not */
    #endif 

#ifdef __SMS_STORAGE_BY_MMI__
    kal_uint8 usm_src_id;
#endif
#if defined(__SMS_STORAGE_BY_MMI__) 
    kal_bool cpms_query;
    kal_bool cpms_set;
    kal_uint8 esmss_mode;
#endif

#ifdef __AT_EPBUM_SUPPORT__
    kal_uint8 phb_anr_occurrence;
    kal_uint8 phb_email_occurrence;
    kal_uint8 phb_sne_occurrence;
    kal_uint8 phb_anr_length;
    kal_uint8 phb_email_length;
    kal_uint8 phb_sne_length;
    kal_uint8 phb_grp_length;
#endif 

#if defined(__CLOG_STORAGE_BY_MMI__)
    kal_uint8 phb_ln_total[PHB_LN_MAX];
    kal_uint8 phb_ln_used[PHB_LN_MAX];
    kal_uint8 phb_ln_free[PHB_LN_MAX];
#endif

#if defined(__SMS_STORAGE_BY_MMI__) && !defined(WISDOM_MMI) 
    kal_uint8 cmss_da_tag;
    l4_addr_bcd_struct cmss_da;
#endif 

    kal_uint8 cmec_keyp; 
    kal_uint8 cmec_disp;
    kal_uint8 cmec_ind;

#if !defined(__MMI_FMI__) && defined(__NBR_CELL_INFO__)
    l4c_nbr_cell_info_ind_struct nbr_info;
#endif

    kal_uint8 is_emgr; 
#if defined(PLUTO_MMI) && (defined(__OP11_ATK__) || defined(__AUTO_ATK__))
    kal_uint8 *appName;
    kal_uint16 appName_len;
#endif

#if !defined(__SLIM_AT__) 
   kal_uint8   ccfc_combi_classx; //original <classx> given by AT+CFCC 
							// each bit is for each classx. (TS or BS) 
							 // 1: we need to make req for this bs_code / 0: ignored
							 //use bit operation 
   kal_uint8   ccfc_current_class; //the class of current req 
   ccfc_req_param_struct ccfc_req_param;  //stores other req parameter information
   kal_bool	ccfc_result;

   kal_uint8   clck_ss_combi_classx; //original <classx> given by AT+CLCK 
							// each bit is for each classx. (TS or BS) 
							 // 1: we need to make req for this bs_code / 0: ignored
							 //use bit operation 
   kal_uint8   clck_ss_current_class; //the class of current req 
   clck_ss_req_param_struct clck_ss_req_param;  //stores other req parameter information
   kal_bool	clck_ss_result;
   smu_security_type_enum clck_sml_type; //for at+clck to query SML status
#endif

   kal_uint8   ccwa_combi_classx; //original <classx> given by AT+CCWA 
							// each bit is for each classx. (TS or BS) 
							 // 1: we need to make req for this bs_code / 0: ignored
							 //use bit operation 
   kal_uint8   ccwa_current_class; //the class of current req 
   ccwa_req_param_struct ccwa_req_param;  //stores other req parameter information
   kal_bool	ccwa_result;
   kal_uint8 cvhu_mode; //MAUI_02862643, mtk02285, support CVHU=1 to ignore ATH

#if !defined(__ULC_AT__)
    rmmi_profile_struct rmmi_default_profile;
    rmmi_profile_struct rmmi_user_profile;
    rmmi_profile_struct rmmi_current_profile;
#endif 	

    rmmi_uart_queue_struct CNMI_ResultCodeBuffer;       //for +CNMI, SMSAL_ONE_MSG_LEN = 160
    kal_uint8 cmd_mode;
#ifndef __MMI_FMI__ 
    kal_uint8 cpbf_findtext[30];
#endif

#ifdef __SAT__
#ifdef __SATCB__
    rmmi_uart_queue_struct sat_output_queue;    //mtk00714 add for SAT using
    kal_bool IsSATcommand;      //check if SATCommand 
    kal_bool IsSATresponse;     //use to check if SAT response
    void *SAT_rsp_ptr;
#endif	
#endif /* __SAT__ */ 

#ifdef __CMUX_SUPPORT__
    kal_uint8 rmmi_data_channel_src;
    kal_uint8 rmmi_urc_channel_src;
#endif 

#if defined(__AT_IPR_WRITE_FS_SUPPORT__)
   kal_uint32 atipr_rate;
#endif

    kal_uint8 csp_plmn_mode;

#if defined(__MESSAGE_BASED_AT_SUPPORT__) 
    kal_bool msg_based_at_enable;
#endif

    kal_uint8 ats0_src_id; //MAUI_02743662 for saving ATS0 auto answer source id

    kal_uint8 cpls_selected;

#if defined(__DUAL_TALK_MODEM_SUPPORT__)
    kal_bool wake_up_ap;
#endif

#if defined(__SYSSEL_SUPPORT__)
    kal_uint8 syssel_band;
#endif

#ifdef __ACMT_SUPPORT__
    kal_uint8 eacmt_mode;
#endif

#if defined(__REPORT_AVAILABLE_PLMN__)
    kal_uint8 ecops_mode;
#endif

#if defined(__2STAGE_NW_SELECTION__)
    kal_uint8 emsr_mode;
#endif

    kal_uint32 is_crla;

#ifndef __UCM_SUPPORT__
    /* This flag is to indicate ATH is redirected to l4c_cc_exe_chld_req()
     * The response is printed in l4c_cc_exe_chld_req() or after CRSS_CNF
     * So rmmi_basic_cmd_processor() shall not print again.
     * Please refer to ALPS00649564.
     */
    kal_uint8 ath_to_chld;
#endif

    module_type tst_inject_mod;  // To record which module sent the tst_inject_string

#ifdef __IMS_SUPPORT__
    kal_uint32 imsp_src_to_mod[MAX_SOURCE_NUM];
#endif

#if defined(__CC_IRQ_EXIST__) && defined(__MTK_TARGET__) && defined(__CDMA2000_RAT__)
    kal_bool MD3_power_off_done;
    l4c_source_id_enum epof_wait_MD3_src_id;

    kal_uint8 emdstatus_md_config;
    kal_uint8 emdstatus_sim_config;
#endif
#if defined(__REPORT_AVAILABLE_PLMN__)
    kal_uint8 number_of_available_plmn_id;
    kal_uint8 available_plmn_id[MAX_PLMN_LIST_LEN][7];
#endif

    kal_bool  data_enabled_setting; // set to 1 if data is enabled in AP
    kal_bool  data_roaming_setting; // set to 1 if data roaming is enabled in AP
} rmmi_context_struct;

typedef struct rmmi_string_struct
{
    kal_uint16 index;
    kal_uint8 *string_ptr;
    kal_uint8 *ip_string;
    l4c_source_id_enum src_id;  // DEREK
    kal_uint8 cmd_mode;
    kal_uint8 cmd_class;  
    kal_uint16 cmd_index;       //rmmi_extended_cmd_id_enum
    kal_uint16 cmd_row_index;    
    rmmi_extend_symbol_hash_enum symbol_hash;
} rmmi_string_struct;

#ifdef __SAT__

typedef enum
{
    RMMI_TIM_MOD_NONE,
    RMMI_TIM_MOD_SAT_DSPL_TEXT,
    RMMI_TIM_MOD_SAT_PLAY_TONE,
    RMMI_TIM_MOD_SAT_REDIAL,
    RMMI_TIM_MOD_SAT_NOTICE,
    RMMI_TIM_MOD_SAT_MMI_INFO,
    RMMI_NUM_OF_TIMER_MOD
}
rmmi_timer_mod_enum;

typedef struct
{
    eventid timer_id;
    kal_uint8 time;
    kal_bool timer_on;
} rmmi_sat_timer_struct;

/* SAT */
#define SAT_SIG_SETUP_MENU_SHOW          70
#define SAT_SIG_SELECT_ITEM_SHOW          71
#define SAT_SIG_DSPL_TXT_SHOW             72
#define SAT_SIG_GET_INKEY_SHOW            73
#define SAT_SIG_GET_INPUT_SHOW            74
#define SAT_SIG_PLAY_TONE_SHOW            75
#define SAT_SIG_SETUP_CALL_SHOW           76
//#define SAT_SIG_SETUP_CALL_REQ_SHOW      77
//#define SAT_SIG_SETUP_CALL_RES_SHOW      78
//#define SAT_SIG_REDIAL_SHOW                79
#define SAT_SIG_SEND_SMS_SHOW            80
#define SAT_SIG_SEND_SS_SHOW              81
#define SAT_SIG_SEND_USSD_SHOW           82
#define SAT_SIG_MMI_INFO_SHOW             83
//#define SAT_SIG_NOTICE_SHOW                85

#define RMMI_SAT_SIG_SETUP_CALL_REQ          16
#define RMMI_SAT_SIG_SEND_SS_REQ             17
#define RMMI_SAT_SIG_SEND_USSD_REQ           18
#define RMMI_SAT_SIG_SEND_SMS_REQ            19
#define RMMI_SAT_SIG_PLAY_TONE_RES           32
#define RMMI_SAT_SIG_DSPL_TEXT_RES           33
#define RMMI_SAT_SIG_GET_INKEY_RES           34
#define RMMI_SAT_SIG_GET_INPUT_RES           35
#define RMMI_SAT_SIG_SELECT_ITEM_RES         36
#define RMMI_SAT_SIG_MENU_SELECT_REQ         37
#define RMMI_SAT_SIG_START_SAT               80
#define RMMI_SAT_SIG_SETUP_CALL_REDIAL       88

typedef struct
{
    kal_uint8 item_len;
    kal_uint8 item_dcs;
    kal_uint8 item_id;
    kal_uint8 *item_data;
}
rmmi_sat_menu_item_struct;

typedef struct
{
    kal_uint8 is_help_info_available;
    kal_uint8 cmd_detail[5];
    kal_uint8 alpha_id_len;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 num_of_item;
    rmmi_sat_menu_item_struct *menu_items;
}
rmmi_sat_main_menu_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_help_info_available;
    kal_uint8 is_item_id_available;
    kal_uint8 item_id;
    kal_uint8 alpha_id_len;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 num_of_item;
    rmmi_sat_menu_item_struct *menu_items;
}
rmmi_sat_sub_menu_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 priority;
    kal_uint8 clear_text_type;
    kal_uint8 immediate_res;
    kal_uint16 no_text_string;
    kal_uint8 *text_string;
    kal_uint8 dcs_of_text_string;
}
rmmi_sat_dspl_text_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_help_info_available;
    kal_uint8 type_of_input;
    kal_uint16 no_text_string;
    kal_uint8 *text_string;
    kal_uint8 dcs_of_text_string;
}
rmmi_sat_get_inkey_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_help_info_available;
    kal_uint8 type_of_input;
    kal_uint8 is_input_revealed_to_user;
    kal_uint8 len_of_min_input;
    kal_uint8 len_of_max_input;

    kal_uint16 no_text_string;
    kal_uint8 *text_string;
    kal_uint8 dcs_of_text_string;
    kal_uint16 no_default_text;
    kal_uint8 *default_text;
    kal_uint8 dcs_of_default_text;
}
rmmi_sat_get_input_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 tone_id;
    kal_uint32 duration;
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;

}
rmmi_sat_play_tone_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 mmi_info_type;
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
}
rmmi_sat_mmi_info_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 condition;
    kal_uint32 duration;

    kal_uint8 no_alpha_id1;
    kal_uint8 *alpha_id1;
    kal_uint8 dcs_of_alpha_id1;
    kal_uint8 no_alpha_id2;
    kal_uint8 *alpha_id2;
    kal_uint8 dcs_of_alpha_id2;

    kal_uint8 size_of_ccp;
    kal_uint8 ccp[MAX_SAT_SIZE_OF_CCP];
    kal_uint8 size_of_subaddr;
    kal_uint8 subaddr[MAX_SIM_SUB_ADDR_BCD_LEN];	

    kal_uint8 no_addr;
    kal_uint8 *addr;
}
rmmi_sat_setup_call_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 is_sms_packed_required;
    kal_uint8 size_of_addr;
    kal_uint8 addr[MAX_SIM_ADDR_LEN];		//mtk02514_081216
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 no_sms_tpdu;
    kal_uint8 *sms_tpdu;
}
rmmi_sat_send_sms_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 no_ss_string;
    kal_uint8 *ss_string;
}
rmmi_sat_send_ss_struct;

typedef struct
{
    kal_uint8 cmd_detail[5];
    kal_uint8 no_alpha_id;
    kal_uint8 *alpha_id;
    kal_uint8 dcs_of_alpha_id;
    kal_uint8 no_ussd_string;
    kal_uint8 *ussd_string;
    kal_uint8 dcs_of_ussd_string;
}
rmmi_sat_send_ussd_struct;

/* TYPES */

typedef enum
{
    RMMI_VTS_SPEECH_IN = 0,
    RMMI_VTS_SPEECH_OUT = 1,
    RMMI_VTS_KEY_BEEP = 2,
    RMMI_VTS_DTMF_TONE = 3,
    RMMI_VTS_RINGER = 4,
    RMMI_VTS_MEDIA = 5,
    RMMI_NUM_OF_VTS_TYPE
}
rmmi_vts_type_enum;

typedef enum
{
    RMMI_VTS_PLAY_CRESCENDO = 0,    /* Play sound for crescendo. */
    RMMI_VTS_PLAY_INFINITE = 1,     /* Play sound for infinite. */
    RMMI_VTS_PLAY_ONCE = 2,         /* Play sound for once. */
    RMMI_VTS_PLAY_DESCENDO = 3,     /* Play sound for descendo. */
    RMMI_VTS_PLAY_OFF = 4,          /* stop sound */
    RMMI_NUM_OF_VTS_PLAY_MODE
}
rmmi_vts_play_mode_enum;

#endif /* __SAT__ */ 

typedef struct
{
    kal_uint8 err_string[RMMI_MAX_ERR_STR_LEN];
} rmmi_error_msg_struct;

//RMMI_UT ---
#define ATCI_MAX_UT_IO_LENGTH 1024
#define ATCI_MAX_UT_CMD_STRING_LENGTH 100
#define ATCI_MAX_UT_AT_PARAMETER_NUMBER 20
#define ATCI_MAX_UT_AT_PARAMETER_STRING_LENGTH 100

typedef struct
{
    kal_uint8 ref_count;
    kal_uint16 msg_len;
    kal_uint8 src_id;
	kal_uint8 port;
    kal_uint8 string[ATCI_MAX_UT_IO_LENGTH];
	kal_bool stuff;
} atci_ut_rmmi_input_string_struct; // MSG_ID_ATCI_UT_RMMI_INPUT_STRING

typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
	kal_uint8 port;
    kal_uint8 string[ATCI_MAX_UT_IO_LENGTH];
	kal_bool stuff;
} atci_ut_rmmi_output_string_struct; // MSG_ID_ATCI_UT_RMMI_OUTPUT_STRING

typedef struct
{
    kal_uint8 para_string[ATCI_MAX_UT_AT_PARAMETER_STRING_LENGTH];
} atci_ut_rmmi_input_expanded_at_parameter_struct;

typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    kal_uint8 port;
    kal_uint8 cmd_string[ATCI_MAX_UT_CMD_STRING_LENGTH];
    atci_ut_rmmi_input_expanded_at_parameter_struct para[ATCI_MAX_UT_AT_PARAMETER_NUMBER];    
} atci_ut_rmmi_input_expanded_at_string_struct; //MSG_ID_ATCI_UT_RMMI_INPUT_EXPANDED_AT_STRING


typedef struct
{
    LOCAL_PARA_HDR
    kal_uint8 src_id;
    kal_uint8 cid;
    l4c_action_enum tcm_current_action;
    l4c_action_enum context_current_action;    
} atci_ut_check_l4c_context_info_struct; // MSG_ID_ATCI_UT_CHECK_L4C_CONTEXT_INFO


//--- RMMI_UT	

typedef void (*RMMI_EXT_CMD_FUNCTION) (rmmi_string_struct *source_string_ptr);

typedef kal_bool(*RMMI_BASIC_CMD_FUNCTION)
    (rmmi_string_struct *source_string_ptr, rmmi_multiple_basic_cmd_struct *head_node_ptr, rmmi_err_id_enum *err_id);

typedef void (*RMMI_IND_FUNCTION) ();


extern rmmi_context_struct *rmmi_ptr_g;
extern rmmi_common_context_struct *rmmi_common_ptr_g;
extern module_type rmmi_current_mod_id;
extern	rmmi_context_struct rmmi_cntxt_g[RMMI_MAX_SIM_NUM];
#if defined(__ATCMD_ONOFF_CHECK__)
extern kal_bool rmmi_check_at_enable;
#endif

#if defined(__DUAL_TALK_MODEM_SUPPORT__)
typedef struct
{
    kal_uint8 speech_mode;
    kal_uint8 rat_mode;
} rmmi_spc_espeech_param_struct;

typedef struct
{
    kal_uint8 sidetone;
} rmmi_spc_esstv_param_struct;

typedef struct
{
    kal_uint8 tone_id;
} rmmi_spc_edtp_param_struct;

typedef struct
{
    kal_uint8 esetdev_mode;
    kal_uint8 src_dev;
} rmmi_spc_esetdev_param_struct;

typedef struct
{
    kal_uint8 volume;
    kal_uint8 gain_id;
} rmmi_spc_esov_param_struct;

typedef struct
{
    kal_uint8 mic_volume;
} rmmi_spc_esmv_param_struct;

typedef struct
{
    kal_uint8 mode;
} rmmi_spc_essma_param_struct;

typedef union
{
    rmmi_spc_espeech_param_struct *espeech_param;
    rmmi_spc_esstv_param_struct *esstv_param;
    rmmi_spc_edtp_param_struct *edtp_param;
    rmmi_spc_esetdev_param_struct *esetdev_param;
    rmmi_spc_esov_param_struct *esov_param;
    rmmi_spc_esmv_param_struct *esmv_param;
    rmmi_spc_essma_param_struct *essma_param;
} rmmi_spc_param_union;
#endif /* __DUAL_TALK_MODEM_SUPPORT__ */

#endif /* _RMMI_CONTEXT_H */

